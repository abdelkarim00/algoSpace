<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Breadth-First Search (BFS) in C++</title>
</head>
<body>

  <h1>Breadth-First Search (BFS)</h1>

  <h2>Algorithm Explanation</h2>
  <p>BFS is a graph traversal algorithm that explores neighbors level by level starting from a source node. It uses a queue data structure to keep track of vertices to be explored.</p>

  <h2>Time and Memory Complexity</h2>
  <ul>
    <li><strong>Time Complexity:</strong> O(V + E), where V = vertices, E = edges.</li>
    <li><strong>Space Complexity:</strong> O(V), for the visited array and queue.</li>
  </ul>

  <h2>Easy Problems</h2>

  <h3>1. Check if a Graph is Bipartite</h3>
  <pre><code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int V) {
    vector&lt;int&gt; color(V, -1);
    for (int start = 0; start &lt; V; ++start) {
        if (color[start] == -1) {
            queue&lt;int&gt; q;
            q.push(start);
            color[start] = 0;
            while (!q.empty()) {
                int u = q.front(); q.pop();
                for (int v : graph[u]) {
                    if (color[v] == -1) {
                        color[v] = 1 - color[u];
                        q.push(v);
                    } else if (color[v] == color[u]) {
                        return false;
                    }
                }
            }
        }
    }
    return true;
}
  </code></pre>

  <h3>2. Find Shortest Path in Unweighted Graph</h3>
  <pre><code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

void bfsShortestPath(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int src, vector&lt;int&gt;&amp; dist) {
    int V = graph.size();
    vector&lt;bool&gt; visited(V, false);
    queue&lt;int&gt; q;
    dist[src] = 0;
    visited[src] = true;
    q.push(src);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : graph[u]) {
            if (!visited[v]) {
                visited[v] = true;
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
}
  </code></pre>

  <h2>Intermediate Problems</h2>

  <h3>1. Number of Islands (Grid Traversal)</h3>
  <pre><code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j) {
    int m = grid.size(), n = grid[0].size();
    queue&lt;pair&lt;int,int&gt;&gt; q;
    q.push({i, j});
    grid[i][j] = '0';
    int dirs[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        for (auto& d : dirs) {
            int nx = x + d[0], ny = y + d[1];
            if (nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == '1') {
                grid[nx][ny] = '0';
                q.push({nx, ny});
            }
        }
    }
}

int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
    int count = 0;
    for (int i = 0; i &lt; grid.size(); i++) {
        for (int j = 0; j &lt; grid[0].size(); j++) {
            if (grid[i][j] == '1') {
                bfs(grid, i, j);
                count++;
            }
        }
    }
    return count;
}
  </code></pre>

  <h3>2. Word Ladder (Shortest Transformation)</h3>
  <pre><code>
#include &lt;iostream&gt;
#include &lt;unordered_set&gt;
#include &lt;queue&gt;
using namespace std;

int ladderLength(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordList) {
    queue&lt;pair&lt;string, int&gt;&gt; q;
    q.push({beginWord, 1});
    while (!q.empty()) {
        auto [word, level] = q.front(); q.pop();
        if (word == endWord) return level;
        for (int i = 0; i &lt; word.size(); ++i) {
            string next = word;
            for (char c = 'a'; c &lt;= 'z'; ++c) {
                next[i] = c;
                if (wordList.count(next)) {
                    wordList.erase(next);
                    q.push({next, level + 1});
                }
            }
        }
    }
    return 0;
}
  </code></pre>

  <h2>Hard Problem</h2>

  <h3>Maze Shortest Path with Obstacles</h3>
  <pre><code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;

int shortestPath(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) {
    int m = grid.size(), n = grid[0].size();
    vector&lt;vector&lt;int&gt;&gt; visited(m, vector&lt;int&gt;(n, -1));
    queue&lt;tuple&lt;int, int, int&gt;&gt; q;
    q.push({0, 0, k});
    visited[0][0] = k;
    int dirs[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};
    int steps = 0;
    while (!q.empty()) {
        int size = q.size();
        while (size--) {
            auto [x, y, remaining] = q.front(); q.pop();
            if (x == m-1 &amp;&amp; y == n-1) return steps;
            for (auto& d : dirs) {
                int nx = x + d[0], ny = y + d[1];
                if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n) {
                    int nk = remaining - grid[nx][ny];
                    if (nk &gt; visited[nx][ny]) {
                        visited[nx][ny] = nk;
                        q.push({nx, ny, nk});
                    }
                }
            }
        }
        steps++;
    }
    return -1;
}
  </code></pre>

</body>
</html>
