<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Binary Search Algorithm - C++ Examples</title>
</head>
<body>

<h1>Binary Search Algorithm</h1>

<h2>ğŸ“˜ Overview</h2>
<p>
  Binary Search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, the search continues in the lower half, or if the value is greater, it continues in the upper half. This process repeats until the value is found or the interval is empty.
</p>

<h2>ğŸ” How It Works</h2>
<ol>
  <li>Start with the middle element of the sorted array.</li>
  <li>If the target value is equal to the middle element, return its index.</li>
  <li>If the target value is less than the middle element, repeat the search on the left subarray.</li>
  <li>If the target value is greater than the middle element, repeat the search on the right subarray.</li>
  <li>If the search interval is empty, the target is not in the array.</li>
</ol>

<h2>â±ï¸ Time Complexity</h2>
<ul>
  <li><strong>Best Case:</strong> O(1) â€” when the target element is the middle element of the array.</li>
  <li><strong>Average Case:</strong> O(log n) â€” the search space is halved with each step.</li>
  <li><strong>Worst Case:</strong> O(log n) â€” the search continues until the search space is reduced to one element.</li>
</ul>
<p>
  Binary Search is significantly faster than linear search, especially for large datasets, due to its logarithmic time complexity.
</p>

<h2>ğŸ’¾ Space Complexity</h2>
<ul>
  <li><strong>Iterative Implementation:</strong> O(1) â€” uses a constant amount of extra space.</li>
  <li><strong>Recursive Implementation:</strong> O(log n) â€” due to the depth of the recursion stack.</li>
</ul>

<h2>âœ… Easy Problems Solvable by Binary Search</h2>

<h3>1. Finding an Element in a Sorted Array</h3>
<p>Given a sorted array of integers and a target value, determine if the target exists in the array.</p>
<pre><code class="cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;

int binarySearch(const std::vector&lt;int&gt;&amp; arr, int target) {
    int low = 0, high = arr.size() - 1;
    while (low &lt;= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] &lt; target) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}

int main() {
    std::vector&lt;int&gt; arr = {1, 3, 5, 7, 9, 11};
    int target = 7;
    int result = binarySearch(arr, target);
    if (result != -1) std::cout &lt;&lt; "Element found at index " &lt;&lt; result &lt;&lt; std::endl;
    else std::cout &lt;&lt; "Element not found" &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<h3>2. Finding the First Occurrence of an Element</h3>
<p>Given a sorted array with duplicate elements, find the index of the first occurrence of a given target value.</p>
<pre><code class="cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;

int findFirstOccurrence(const std::vector&lt;int&gt;&amp; arr, int target) {
    int low = 0, high = arr.size() - 1, result = -1;
    while (low &lt;= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) {
            result = mid;
            high = mid - 1; // Move left to find first occurrence
        } else if (arr[mid] &lt; target) low = mid + 1;
        else high = mid - 1;
    }
    return result;
}

int main() {
    std::vector&lt;int&gt; arr = {1, 2, 2, 2, 3, 4};
    int target = 2;
    int result = findFirstOccurrence(arr, target);
    if (result != -1) std::cout &lt;&lt; "First occurrence at index " &lt;&lt; result &lt;&lt; std::endl;
    else std::cout &lt;&lt; "Element not found" &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<h2>ğŸ” Intermediate Problems Solvable by Binary Search</h2>

<h3>1. Finding the Square Root of a Number</h3>
<p>Given a non-negative integer, find its square root without using built-in functions.</p>
<pre><code class="cpp">
#include &lt;iostream&gt;

int sqrtBinarySearch(int x) {
    if (x == 0 || x == 1) return x;
    int low = 1, high = x, result = -1;
    while (low &lt;= high) {
        int mid = low + (high - low) / 2;
        if (mid * mid == x) return mid;
        else if (mid * mid &lt; x) {
            low = mid + 1;
            result = mid;
        } else high = mid - 1;
    }
    return result;
}

int main() {
    int x = 16;
    std::cout &lt;&lt; "Square root of " &lt;&lt; x &lt;&lt; " is " &lt;&lt; sqrtBinarySearch(x) &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<h3>2. Finding the Peak Element in an Array</h3>
<p>Given an array where each element is greater than or equal to its neighbors, find a peak element.</p>
<pre><code class="cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;

int findPeakElement(const std::vector&lt;int&gt;&amp; nums) {
    int low = 0, high = nums.size() - 1;
    while (low &lt;= high) {
        int mid = low + (high - low) / 2;
        if ((mid == 0 || nums[mid - 1] &lt;= nums[mid]) &&
            (mid == nums.size() - 1 || nums[mid + 1] &lt;= nums[mid]))
            return mid;
        else if (mid &gt; 0 && nums[mid - 1] &gt; nums[mid]) high = mid - 1;
        else low = mid + 1;
    }
    return -1;
}

int main() {
    std::vector&lt;int&gt; nums = {1, 3, 20, 4, 1};
    std::cout &lt;&lt; "Peak element at index " &lt;&lt; findPeakElement(nums) &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<h2>ğŸ§  Advanced Problem Solvable by Binary Search</h2>

<h3>1. Finding the Minimum in a Rotated Sorted Array</h3>
<p>Given a rotated sorted array, find the minimum element.</p>
<pre><code class="cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;

int findMinInRotatedArray(const std::vector&lt;int&gt;&amp; nums) {
    int low = 0, high = nums.size() - 1;
    while (low &lt;= high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] &lt; nums[high]) high = mid;
        else low = mid + 1;
    }
    return nums[low];
}

int main() {
    std::vector&lt;int&gt; nums = {4, 5, 6, 7, 0, 1, 2};
    std::cout &lt;&lt; "Minimum element is " &lt;&lt; findMinInRotatedArray(nums) &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<h2>ğŸ“Œ Summary</h2>
<ul>
  <li><strong>Binary Search</strong> is an efficient algorithm for finding an item from a sorted list of items.</li>
  <li>It has a time complexity of O(log n), making it faster than linear search for large datasets.</li>
  <li>Its space complexity is O(1) for iterative implementations and O(log n) for recursive implementations.</li>
  <li>Binary Search can be applied to various problems, including finding elements, computing square roots, and identifying peak elements.</li>
</ul>
</body>
</html>
