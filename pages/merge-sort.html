<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Merge Sort Algorithm - Analysis and Examples</title>
</head>
<body>

<h1>Merge Sort Algorithm</h1>

<h2>üìå Overview</h2>
<p>
  Merge Sort is a classic divide-and-conquer algorithm that splits an array into halves, recursively sorts each half, and merges the sorted halves back together. It's known for its predictable O(n log n) time complexity and is a stable sort.
</p>

<h2>üß† Algorithm Steps</h2>
<ol>
  <li>Divide the array into two halves.</li>
  <li>Recursively sort each half.</li>
  <li>Merge the two sorted halves.</li>
</ol>

<h2>‚è±Ô∏è Time Complexity</h2>
<ul>
  <li><strong>Best Case:</strong> O(n log n)</li>
  <li><strong>Average Case:</strong> O(n log n)</li>
  <li><strong>Worst Case:</strong> O(n log n)</li>
</ul>

<h2>üíæ Space Complexity</h2>
<ul>
  <li><strong>Auxiliary Space:</strong> O(n) due to temporary arrays during merging</li>
</ul>

<hr>

<h2>‚úÖ Easy Problems Solvable by Merge Sort</h2>

<h3>1. Sort a List of Integers</h3>
<pre><code>
void merge(int arr[], int l, int m, int r) {
    int n1 = m - l + 1, n2 = r - m;
    int L[n1], R[n2];

    for (int i = 0; i &lt; n1; i++) L[i] = arr[l + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[m + 1 + j];

    int i = 0, j = 0, k = l;
    while (i &lt; n1 &amp;&amp; j &lt; n2)
        arr[k++] = (L[i] &lt;= R[j]) ? L[i++] : R[j++];

    while (i &lt; n1) arr[k++] = L[i++];
    while (j &lt; n2) arr[k++] = R[j++];
}

void mergeSort(int arr[], int l, int r) {
    if (l &lt; r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}
</code></pre>

<h3>2. Merge Two Sorted Arrays</h3>
<pre><code>
void mergeTwoSortedArrays(int A[], int n, int B[], int m, int C[]) {
    int i = 0, j = 0, k = 0;
    while (i &lt; n &amp;&amp; j &lt; m)
        C[k++] = (A[i] &lt; B[j]) ? A[i++] : B[j++];
    while (i &lt; n) C[k++] = A[i++];
    while (j &lt; m) C[k++] = B[j++];
}
</code></pre>

<hr>

<h2>üîÅ Intermediate Problems Solvable by Merge Sort</h2>

<h3>1. Count Inversions in an Array</h3>
<pre><code>
int mergeAndCount(int arr[], int l, int m, int r) {
    int n1 = m - l + 1, n2 = r - m;
    int L[n1], R[n2];
    for (int i = 0; i &lt; n1; i++) L[i] = arr[l + i];
    for (int j = 0; j &lt; n2; j++) R[j] = arr[m + 1 + j];

    int i = 0, j = 0, k = l, inv_count = 0;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) arr[k++] = L[i++];
        else {
            arr[k++] = R[j++];
            inv_count += (n1 - i); // elements remaining in L[]
        }
    }
    while (i &lt; n1) arr[k++] = L[i++];
    while (j &lt; n2) arr[k++] = R[j++];
    return inv_count;
}

int mergeSortAndCount(int arr[], int l, int r) {
    int count = 0;
    if (l &lt; r) {
        int m = l + (r - l) / 2;
        count += mergeSortAndCount(arr, l, m);
        count += mergeSortAndCount(arr, m + 1, r);
        count += mergeAndCount(arr, l, m, r);
    }
    return count;
}
</code></pre>

<h3>2. Sort Linked List (Merge Sort for Linked List)</h3>
<pre><code>
struct ListNode {
    int val;
    ListNode* next;
};

ListNode* merge(ListNode* l1, ListNode* l2) {
    if (!l1) return l2;
    if (!l2) return l1;

    if (l1-&gt;val &lt;= l2-&gt;val) {
        l1-&gt;next = merge(l1-&gt;next, l2);
        return l1;
    } else {
        l2-&gt;next = merge(l1, l2-&gt;next);
        return l2;
    }
}

ListNode* mergeSort(ListNode* head) {
    if (!head || !head-&gt;next) return head;

    ListNode *slow = head, *fast = head-&gt;next;
    while (fast &amp;&amp; fast-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }

    ListNode* mid = slow-&gt;next;
    slow-&gt;next = nullptr;

    ListNode* left = mergeSort(head);
    ListNode* right = mergeSort(mid);

    return merge(left, right);
}
</code></pre>

<hr>

<h2>üß† Hard Problem Solvable by Merge Sort</h2>

<h3>1. External Sorting (Sorting Big Files That Don‚Äôt Fit in Memory)</h3>
<p>
  Merge Sort is ideal for external sorting due to its sequential access pattern. Files are split into chunks that are sorted in memory, then merged using a k-way merge.
</p>
<pre><code>
// Pseudocode representation of external merge sort logic
// Real implementation would involve file I/O and buffers

// Step 1: Sort chunks and store as temporary files
// Step 2: Perform k-way merge to combine sorted chunks

// Use priority_queue (min-heap) for k-way merging
</code></pre>

</body>
</html>
