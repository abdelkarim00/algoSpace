
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tarjan's Algorithm Explained with C++ Code Examples</title>
</head>
<body>
    <h1>Tarjan's Algorithm</h1>
    <section>
        <h2>Algorithm Explanation</h2>
        <p>Tarjan's algorithm is used to find Strongly Connected Components (SCCs) in a directed graph. It uses a depth-first search (DFS) and maintains arrays for discovery time and low-link values.</p>
        <ul>
            <li><strong>Time Complexity:</strong> O(V + E)</li>
            <li><strong>Space Complexity:</strong> O(V)</li>
        </ul>
    </section>

    <section>
        <h2>Easy Problems</h2>
        <h3>1. Find all Strongly Connected Components</h3>
        <pre><code>void tarjanSCC(int u, vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;int&gt;&amp; disc, vector&lt;int&gt;&amp; low, stack&lt;int&gt;&amp; st, vector&lt;bool&gt;&amp; inStack, int&amp; time, vector&lt;vector&lt;int&gt;&gt;&amp; sccs) {
    disc[u] = low[u] = time++;
    st.push(u); inStack[u] = true;
    for (int v : adj[u]) {
        if (disc[v] == -1) {
            tarjanSCC(v, adj, disc, low, st, inStack, time, sccs);
            low[u] = min(low[u], low[v]);
        } else if (inStack[v]) {
            low[u] = min(low[u], disc[v]);
        }
    }
    if (low[u] == disc[u]) {
        vector&lt;int&gt; scc;
        int v;
        do {
            v = st.top(); st.pop(); inStack[v] = false;
            scc.push_back(v);
        } while (u != v);
        sccs.push_back(scc);
    }
}
        </code></pre>

        <h3>2. Count number of SCCs in a Graph</h3>
        <pre><code>int countSCCs(int V, vector&lt;vector&lt;int&gt;&gt;&amp; adj) {
    vector&lt;int&gt; disc(V, -1), low(V, -1);
    vector&lt;bool&gt; inStack(V, false);
    stack&lt;int&gt; st;
    int time = 0, count = 0;
    for (int i = 0; i &lt; V; ++i) {
        if (disc[i] == -1) {
            vector&lt;vector&lt;int&gt;&gt; sccs;
            tarjanSCC(i, adj, disc, low, st, inStack, time, sccs);
            count += sccs.size();
        }
    }
    return count;
}
        </code></pre>
    </section>

    <section>
        <h2>Intermediate Problems</h2>
        <h3>1. Detect Cycles in Directed Graph</h3>
        <p>Any SCC with more than one node implies a cycle.</p>

        <h3>2. Condense Graph into DAG of SCCs</h3>
        <p>After identifying SCCs, treat each as a single node and construct a DAG.</p>
    </section>

    <section>
        <h2>Hard Problem</h2>
        <h3>1. 2-SAT Problem Solver</h3>
        <p>Convert clauses into implication graph and use Tarjanâ€™s to find SCCs.</p>
        <pre><code>bool twoSAT(int n, vector&lt;pair&lt;int, int&gt;&gt;& clauses) {
    // convert clauses to implication graph, build SCCs with Tarjan, 
    // check if variable and its negation are in the same SCC
    // implementation skipped for brevity
    return true;
}
        </code></pre>
    </section>
</body>
</html>
