<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Traversal Visualizer</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.9/dist/vis-network.min.css" rel="stylesheet" type="text/css" />
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #333;
            margin-top: 20px;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            width: 95%;
            max-width: 1200px;
            margin-top: 20px;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 20px;
        }

        .controls {
            flex: 1;
            min-width: 300px;
            padding: 20px;
            margin-right: 20px;
            border-right: 1px solid #ddd;
        }

        .controls h2 {
            margin-top: 0;
            color: #555;
        }

        .input-method button {
            padding: 10px;
            margin-right: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            cursor: pointer;
            border-radius: 4px;
        }

        .input-method button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        #textInputArea {
            margin-top: 15px;
        }

        textarea#graphInput {
            width: calc(100% - 22px);
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            min-height: 100px;
        }

        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #0056b3;
        }

        button#resetTraversal, button#submitTextGraph {
            background-color: #6c757d;
        }
        button#resetTraversal:hover, button#submitTextGraph:hover {
            background-color: #545b62;
        }

        #traversalControls, #speedControl {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        #traversalControls label, #speedControl label {
            display: block;
            margin-bottom: 5px;
        }

        #traversalControls input[type="text"],
        #traversalControls select {
            width: calc(100% - 22px);
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        #speedControl input[type="range"] {
            width: 100%;
        }

        .visualizer-area {
            flex: 2;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #network {
            width: 100%;
            min-height: 400px;
            height: 500px;
            border: 1px solid #ccc;
            background-color: #fff;
            border-radius: 4px;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            .controls {
                margin-right: 0;
                margin-bottom: 20px;
                border-right: none;
                border-bottom: 1px solid #ddd;
            }
        }

        .path-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <h1>Graph Traversal Visualizer üï∏Ô∏è</h1>

    <div class="container">
        <div class="controls">
            <h2>Define Graph</h2>
            <div class="input-method">
                <button id="textInputBtn" class="active">Text Input</button>
                <button id="visualEditorBtn">Visual Editor</button>
            </div>

            <div id="textInputArea">
                <label for="graphInput">Enter Edges (e.g., "1 2" or "1 2 6" per line):</label>
                <textarea id="graphInput" rows="10" placeholder="1 2&#10;1 3 5&#10;2 4"></textarea>
                <button id="submitTextGraph">Create Graph from Text</button>
            </div>

            <div id="traversalControls">
                <h2>Traversal</h2>
                <label for="startNode">Start Node:</label>
                <input type="text" id="startNode" placeholder="e.g., 1">
                <label for="endNode">End Node (for Dijkstra):</label>
                <input type="text" id="endNode" placeholder="e.g., 4">
                <select id="traversalAlgorithm">
                    <option value="bfs">Breadth-First Search (BFS)</option>
                    <option value="dfs">Depth-First Search (DFS)</option>
                    <option value="dijkstra">Dijkstra's Algorithm</option>
                </select>
                <button id="runTraversal">Run Traversal</button>
                <button id="resetTraversal">Reset Visuals</button>
            </div>
             <div id="speedControl">
                <label for="animationSpeed">Animation Speed:</label>
                <input type="range" id="animationSpeed" min="100" max="2000" value="500" step="100">
            </div>
        </div>

        <div class="visualizer-area">
            <h2>Graph Visualization</h2>
            <div id="network"></div>
            <div id="pathInfo" class="path-info" style="display: none;">
                <h3>Path Information</h3>
                <p id="pathDetails"></p>
                <p id="pathLength"></p>
            </div>
        </div>
    </div>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.9/dist/vis-network.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const graphInput = document.getElementById('graphInput');
            const submitTextGraphBtn = document.getElementById('submitTextGraph');
            const networkContainer = document.getElementById('network');
            const startNodeInput = document.getElementById('startNode');
            const endNodeInput = document.getElementById('endNode');
            const traversalAlgorithmSelect = document.getElementById('traversalAlgorithm');
            const runTraversalBtn = document.getElementById('runTraversal');
            const resetTraversalBtn = document.getElementById('resetTraversal');
            const textInputBtn = document.getElementById('textInputBtn');
            const visualEditorBtn = document.getElementById('visualEditorBtn');
            const textInputArea = document.getElementById('textInputArea');
            const animationSpeedSlider = document.getElementById('animationSpeed');
            const pathInfo = document.getElementById('pathInfo');
            const pathDetails = document.getElementById('pathDetails');
            const pathLength = document.getElementById('pathLength');

            let nodes = new vis.DataSet([]);
            let edges = new vis.DataSet([]);
            let network = null;
            let rawGraphData = { nodes: new Set(), edges: [] };
            let animationDelay = 500;

            const defaultNodeColor = {
                border: '#2B7CE9',
                background: '#97C2FC',
                highlight: {
                    border: '#2B7CE9',
                    background: '#D2E5FF'
                },
                hover: {
                    border: '#2B7CE9',
                    background: '#D2E5FF'
                }
            };

            const defaultEdgeColor = '#848484';
            const defaultEdgeWidth = 2;
            const visitedNodeColor = { background: '#34c131', border: 'green' };
            const visitingNodeColor = { background: 'orange', border: 'darkorange' };
            const discoveredNodeColor = { background: '#a0e89f', border: 'darkgreen' };
            const pathEdgeColor = { color: '#ff5722', width: 4 };
            const visitedEdgeColor = { color: '#34c131', width: 4 };

            const defaultOptions = {
                physics: {
                    enabled: true,
                    solver: 'barnesHut',
                    barnesHut: {
                        gravitationalConstant: -4000,
                        centralGravity: 0.15,
                        springLength: 120,
                        springConstant: 0.05,
                        damping: 0.09,
                        avoidOverlap: 0.15
                    },
                    stabilization: {
                        iterations: 1500,
                        fit: true
                    }
                },
                interaction: {
                    dragNodes: true,
                    dragView: true,
                    hover: true,
                    tooltipDelay: 200,
                    zoomView: true,
                    navigationButtons: true,
                    keyboard: true
                },
                manipulation: {
                    enabled: false,
                    addNode: function (data, callback) {
                        data.label = prompt("Enter node ID/label:", "");
                        if (data.label !== null && data.label.trim() !== "") {
                            data.id = data.label.trim();
                            if (rawGraphData.nodes.has(data.id)) {
                                alert("Node ID already exists!");
                                callback(null);
                                return;
                            }
                            rawGraphData.nodes.add(data.id);
                            data.color = defaultNodeColor;
                            callback(data);
                        } else {
                            callback(null);
                        }
                    },
                    addEdge: function (data, callback) {
                        if (data.from === data.to) {
                            alert("Cannot connect node to itself (self-loops disabled in this mode).");
                            callback(null);
                            return;
                        }
                        const weightInput = prompt("Enter edge weight (optional, number):", "");
                        let weight = null;
                        let label = "";
                        if (weightInput !== null && weightInput.trim() !== "") {
                            weight = parseInt(weightInput);
                            if (isNaN(weight)) {
                                alert("Weight must be a number.");
                                callback(null);
                                return;
                            }
                            label = String(weight);
                        }
                        data.label = label;
                        data.arrows = 'to';
                        rawGraphData.edges.push({ from: data.from, to: data.to, weight: weight });
                        callback(data);
                    },
                    editNode: function (data, callback) {
                        const newLabel = prompt("Edit node ID/label:", data.label);
                        if (newLabel !== null && newLabel.trim() !== "" && newLabel.trim() !== data.id) {
                            const newId = newLabel.trim();
                            if (rawGraphData.nodes.has(newId)) {
                                alert("Node ID already exists!");
                                callback(null);
                                return;
                            }
                            rawGraphData.nodes.delete(data.id);
                            rawGraphData.nodes.add(newId);
                            rawGraphData.edges.forEach(edge => {
                                if (edge.from === data.id) edge.from = newId;
                                if (edge.to === data.id) edge.to = newId;
                            });
                            data.id = newId;
                            data.label = newId;
                        }
                        callback(data);
                    },
                    deleteNode: function (data, callback) {
                        data.nodes.forEach(nodeId => {
                            nodes.remove(nodeId);
                            rawGraphData.nodes.delete(nodeId);
                        });
                        rawGraphData.edges = rawGraphData.edges.filter(edge =>
                            !data.nodes.includes(edge.from) && !data.nodes.includes(edge.to)
                        );
                        callback(data);
                    },
                    deleteEdge: function (data, callback) {
                        data.edges.forEach(edgeId => {
                            const deletedVisEdge = edges.get(edgeId);
                            if(deletedVisEdge) {
                                rawGraphData.edges = rawGraphData.edges.filter(rawEdge =>
                                    !(rawEdge.from === deletedVisEdge.from && rawEdge.to === deletedVisEdge.to && 
                                      (rawEdge.weight === (parseInt(deletedVisEdge.label) || null) || 
                                      (!rawEdge.weight && !deletedVisEdge.label)))
                                );
                                edges.remove(edgeId);
                            }
                        });
                        callback(data);
                    }
                },
                nodes: {
                    shape: 'ellipse',
                    size: 22,
                    font: {
                        size: 14,
                        color: '#333333'
                    },
                    borderWidth: 2,
                    color: defaultNodeColor
                },
                edges: {
                    width: defaultEdgeWidth,
                    color: {
                        color: defaultEdgeColor,
                        highlight: '#007bff',
                        hover: '#0056b3'
                    },
                    arrows: {
                        to: { enabled: true, scaleFactor: 0.7, type: 'arrow' }
                    },
                    font: {
                        align: 'middle',
                        size: 12,
                        color: '#444',
                        strokeWidth: 3,
                        strokeColor: '#ffffff'
                    },
                    smooth: {
                        enabled: true,
                        type: "dynamic",
                        roundness: 0.5
                    }
                }
            };

            function initializeGraph(enableManipulation = false) {
                if (network) {
                    network.destroy();
                }
                const data = { nodes: nodes, edges: edges };
                const options = JSON.parse(JSON.stringify(defaultOptions));
                options.manipulation.enabled = enableManipulation;

                network = new vis.Network(networkContainer, data, options);

                network.on("stabilizationIterationsDone", function () {
                    network.fit();
                });

                if (enableManipulation) {
                    document.getElementById('textInputArea').style.display = 'none';
                    
                    if (rawGraphData.nodes.size > 0 && nodes.length === 0) {
                        rawGraphData.nodes.forEach(nodeId => {
                            if (!nodes.get(nodeId)) {
                                nodes.add({ id: nodeId, label: nodeId, color: defaultNodeColor });
                            }
                        });
                        rawGraphData.edges.forEach(edge => {
                            const edgeExists = edges.get({
                                filter: e => e.from === edge.from && e.to === edge.to && 
                                            (parseInt(e.label) || null) === edge.weight
                            });
                            if (edgeExists.length === 0) {
                                edges.add({
                                    from: edge.from,
                                    to: edge.to,
                                    label: edge.weight !== null ? String(edge.weight) : '',
                                    arrows: 'to',
                                    color: defaultEdgeColor,
                                    width: defaultEdgeWidth
                                });
                            }
                        });
                    }
                } else {
                    document.getElementById('textInputArea').style.display = 'block';
                }
            }

            function resetAllGraphData() {
                nodes.clear();
                edges.clear();
                rawGraphData = { nodes: new Set(), edges: [] };
                graphInput.value = '';
                startNodeInput.value = '';
                endNodeInput.value = '';
                pathInfo.style.display = 'none';
                if (network) {
                    network.setData({ nodes: nodes, edges: edges });
                }
            }

            submitTextGraphBtn.addEventListener('click', () => {
                try {
                    nodes.clear();
                    edges.clear();
                    rawGraphData = { nodes: new Set(), edges: [] };
                    
                    const inputText = graphInput.value.trim();
                    if (!inputText) {
                        alert("Please enter graph data in the text area.");
                        return;
                    }

                    const lines = inputText.split('\n');
                    const nodeMap = new Map();
                    const edgeList = [];

                    lines.forEach((line, lineNumber) => {
                        line = line.trim();
                        if (!line) return;

                        const parts = line.split(/\s+/).filter(part => part !== '');
                        
                        if (parts.length < 2 || parts.length > 3) {
                            throw new Error(`Line ${lineNumber + 1}: Each line must have 2 or 3 parts (node1 node2 [weight]). Found ${parts.length} parts.`);
                        }

                        const from = parts[0];
                        const to = parts[1];
                        let weight = null;

                        if (!from || !to) {
                            throw new Error(`Line ${lineNumber + 1}: Node IDs cannot be empty.`);
                        }

                        if (parts.length === 3) {
                            weight = parseFloat(parts[2]);
                            if (isNaN(weight)) {
                                throw new Error(`Line ${lineNumber + 1}: Weight must be a number. Found '${parts[2]}'`);
                            }
                        }

                        if (!nodeMap.has(from)) {
                            nodeMap.set(from, { id: from, label: from });
                        }
                        if (!nodeMap.has(to)) {
                            nodeMap.set(to, { id: to, label: to });
                        }

                        edgeList.push({
                            from: from,
                            to: to,
                            weight: weight,
                            label: weight !== null ? String(weight) : '',
                            arrows: 'to'
                        });
                    });

                    nodeMap.forEach((node, id) => {
                        rawGraphData.nodes.add(id);
                    });
                    edgeList.forEach(edge => {
                        rawGraphData.edges.push({
                            from: edge.from,
                            to: edge.to,
                            weight: edge.weight
                        });
                    });

                    const visNodes = Array.from(nodeMap.values()).map(node => ({
                        ...node,
                        color: defaultNodeColor
                    }));

                    const visEdges = edgeList.map(edge => ({
                        ...edge,
                        color: defaultEdgeColor,
                        width: defaultEdgeWidth
                    }));

                    nodes.update(visNodes);
                    edges.update(visEdges);

                    initializeGraph(false);
                    
                    if (network) {
                        network.once('stabilizationIterationsDone', () => {
                            network.fit({
                                animation: {
                                    duration: 1000,
                                    easingFunction: 'easeInOutQuad'
                                }
                            });
                        });
                    }

                } catch (error) {
                    alert(error.message);
                    console.error(error);
                    resetAllGraphData();
                }
            });

            textInputBtn.addEventListener('click', () => {
                textInputBtn.classList.add('active');
                visualEditorBtn.classList.remove('active');
                initializeGraph(false);
            });

            visualEditorBtn.addEventListener('click', () => {
                visualEditorBtn.classList.add('active');
                textInputBtn.classList.remove('active');
                initializeGraph(true);
            });

            function resetTraversalVisualization() {
                nodes.getIds().forEach(id => {
                    nodes.update({ id: id, color: defaultNodeColor });
                });
                edges.getIds().forEach(edgeId => {
                    edges.update({
                        id: edgeId,
                        color: defaultEdgeColor,
                        width: defaultEdgeWidth
                    });
                });
                pathInfo.style.display = 'none';
                if (network) {
                    network.unselectAll();
                }
            }

            resetTraversalBtn.addEventListener('click', resetTraversalVisualization);

            animationSpeedSlider.addEventListener('input', (event) => {
                animationDelay = parseInt(event.target.value);
            });

            runTraversalBtn.addEventListener('click', async () => {
                const startNodeId = startNodeInput.value.trim();
                const endNodeId = endNodeInput.value.trim();
                const algorithm = traversalAlgorithmSelect.value;

                if (!startNodeId) {
                    alert("Please enter a start node.");
                    return;
                }
                if (!rawGraphData.nodes.has(startNodeId)) {
                    alert("Start node not found in the graph.");
                    return;
                }
                if (rawGraphData.nodes.size === 0) {
                    alert("Graph is empty. Please define a graph first.");
                    return;
                }
                if (algorithm === 'dijkstra' && !endNodeId) {
                    alert("Please enter an end node for Dijkstra's algorithm.");
                    return;
                }
                if (algorithm === 'dijkstra' && !rawGraphData.nodes.has(endNodeId)) {
                    alert("End node not found in the graph.");
                    return;
                }

                resetTraversalVisualization();

                // Build adjacency list
                const adj = {};
                rawGraphData.nodes.forEach(node => adj[node] = []);
                rawGraphData.edges.forEach(edge => {
                    const weight = edge.weight !== null ? edge.weight : 1;
                    adj[edge.from].push({node: edge.to, weight: weight});
                });

                if (algorithm === 'bfs') {
                    await bfs(startNodeId, adj);
                } else if (algorithm === 'dfs') {
                    await dfs(startNodeId, adj);
                } else if (algorithm === 'dijkstra') {
                    await dijkstra(startNodeId, endNodeId, adj);
                }
            });

            async function highlightNode(nodeId, style = visitedNodeColor) {
                nodes.update({ id: nodeId, color: style });
                await new Promise(resolve => setTimeout(resolve, animationDelay));
            }

            async function highlightEdge(fromNode, toNode, style = visitedEdgeColor) {
                const edgesBetween = edges.get({
                    filter: edge => edge.from === fromNode && edge.to === toNode
                });

                for (const edge of edgesBetween) {
                    edges.update({ 
                        id: edge.id, 
                        color: style.color, 
                        width: style.width 
                    });
                }
                await new Promise(resolve => setTimeout(resolve, animationDelay));
            }

            async function bfs(startNode, adj) {
                const visited = new Set();
                const queue = [startNode];
                visited.add(startNode);

                await highlightNode(startNode, visitingNodeColor);

                let count = 0;
                const maxIterations = rawGraphData.nodes.size * 2;

                while (queue.length > 0 && count < maxIterations) {
                    count++;
                    const u = queue.shift();
                    await highlightNode(u, visitedNodeColor);

                    if(adj[u]) {
                        for (const edgeInfo of adj[u]) {
                            const v = edgeInfo.node;
                            if (!visited.has(v)) {
                                visited.add(v);
                                await highlightEdge(u, v);
                                await highlightNode(v, discoveredNodeColor);
                                queue.push(v);
                            }
                        }
                    }
                }
                if (count >= maxIterations) console.warn("BFS safety break triggered.");
            }

            async function dfsUtil(u, adj, visited) {
                visited.add(u);
                await highlightNode(u, visitedNodeColor);

                if (adj[u]) {
                    for (const edgeInfo of adj[u]) {
                        const v = edgeInfo.node;
                        if (!visited.has(v)) {
                            await highlightEdge(u, v);
                            await dfsUtil(v, adj, visited);
                        }
                    }
                }
            }

            async function dfs(startNode, adj) {
                const visited = new Set();
                await highlightNode(startNode, visitingNodeColor);
                await dfsUtil(startNode, adj, visited);
            }

            async function dijkstra(startNode, endNode, adj) {
                // Initialize distances and previous nodes
                const distances = {};
                const previous = {};
                const visited = new Set();
                const unvisited = new Set(rawGraphData.nodes);
                
                rawGraphData.nodes.forEach(node => {
                    distances[node] = Infinity;
                    previous[node] = null;
                });
                distances[startNode] = 0;
                
                // Highlight start node
                await highlightNode(startNode, visitingNodeColor);
                
                while (unvisited.size > 0) {
                    // Find node with smallest distance
                    let current = null;
                    let smallestDistance = Infinity;
                    
                    for (const node of unvisited) {
                        if (distances[node] < smallestDistance) {
                            smallestDistance = distances[node];
                            current = node;
                        }
                    }
                    
                    if (current === null || current === endNode) break;
                    
                    // Mark as visited
                    unvisited.delete(current);
                    visited.add(current);
                    await highlightNode(current, visitedNodeColor);
                    
                    // Update neighbors
                    if (adj[current]) {
                        for (const edge of adj[current]) {
                            const neighbor = edge.node;
                            if (visited.has(neighbor)) continue;
                            
                            const alt = distances[current] + edge.weight;
                            if (alt < distances[neighbor]) {
                                distances[neighbor] = alt;
                                previous[neighbor] = current;
                                
                                // Highlight the edge and node
                                await highlightEdge(current, neighbor);
                                await highlightNode(neighbor, discoveredNodeColor);
                            }
                        }
                    }
                }
                
                // Reconstruct path
                const path = [];
                let current = endNode;
                while (current !== null) {
                    path.unshift(current);
                    current = previous[current];
                }
                
                // Display path information
                if (path.length > 1) {
                    pathDetails.textContent = `Path: ${path.join(' ‚Üí ')}`;
                    pathLength.textContent = `Total distance: ${distances[endNode]}`;
                    pathInfo.style.display = 'block';
                    
                    // Highlight the path
                    for (let i = 0; i < path.length - 1; i++) {
                        await highlightEdge(path[i], path[i+1], pathEdgeColor);
                        await highlightNode(path[i], visitingNodeColor);
                    }
                    await highlightNode(path[path.length-1], visitingNodeColor);
                } else {
                    pathDetails.textContent = "No path found";
                    pathLength.textContent = "";
                    pathInfo.style.display = 'block';
                }
            }

            // Initialize with text input mode by default
            initializeGraph(false);
        });
    </script>
</body>
</html>