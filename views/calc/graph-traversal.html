<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Traversal Visualizer</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.9/dist/vis-network.min.css" rel="stylesheet" type="text/css" />
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #333;
            margin-top: 20px;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            width: 95%;
            max-width: 1200px;
            margin-top: 20px;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 20px;
        }

        .controls {
            flex: 1;
            min-width: 300px;
            padding: 20px;
            margin-right: 20px;
            border-right: 1px solid #ddd;
        }

        .controls h2 {
            margin-top: 0;
            color: #555;
        }

        .input-method button {
            padding: 10px;
            margin-right: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            cursor: pointer;
            border-radius: 4px;
        }

        .input-method button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        #textInputArea {
            margin-top: 15px;
        }

        textarea#graphInput {
            width: calc(100% - 22px);
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            min-height: 100px;
        }

        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #0056b3;
        }

        button#resetTraversal, button#submitTextGraph {
            background-color: #6c757d;
        }
        button#resetTraversal:hover, button#submitTextGraph:hover {
            background-color: #545b62;
        }

        #traversalControls, #speedControl {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        #traversalControls label, #speedControl label {
            display: block;
            margin-bottom: 5px;
        }

        #traversalControls input[type="text"],
        #traversalControls select {
            width: calc(100% - 22px);
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        #speedControl input[type="range"] {
            width: 100%;
        }

        .visualizer-area {
            flex: 2;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #network {
            width: 100%;
            min-height: 400px;
            height: 500px;
            border: 1px solid #ccc;
            background-color: #fff;
            border-radius: 4px;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            .controls {
                margin-right: 0;
                margin-bottom: 20px;
                border-right: none;
                border-bottom: 1px solid #ddd;
            }
        }

        .path-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }

        .negative-cycle {
            background-color: #ffdddd;
            border-left: 4px solid #ff0000;
            padding: 10px;
            margin-top: 10px;
        }

        .traversal-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .traversal-controls button {
            flex: 1;
        }

        #pauseTraversal {
            background-color: #ffc107;
        }

        #pauseTraversal:hover {
            background-color: #e0a800;
        }
                .reasoning-panel {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
            min-height: 60px;
            font-family: monospace;
            white-space: pre-wrap;
            border-left: 4px solid #007bff;
        }

        .reasoning-panel {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
            min-height: 60px;
            font-family: monospace;
            white-space: pre-wrap;
            border-left: 4px solid #007bff;
            position: relative;
        }

        .reasoning-content {
            max-height: 150px;
            overflow-y: auto;
        }

        .reasoning-line {
            margin-bottom: 5px;
            padding: 3px;
            border-radius: 3px;
            display: none; /* Initially hidden */
        }

        .reasoning-line.active {
            display: block;
            background-color: #fffde7;
            font-weight: bold;
        }

        .reasoning-line.ignored {
            color: #888;
        }

        .reasoning-line.selected {
            color: #2e7d32;
        }

        .reasoning-line.error {
            color: #c62828;
        }

        .reasoning-line.info {
            color: #1565c0;
        }

        .reasoning-nav {
            display: none;
            justify-content: space-between;
            margin-top: 10px;
        }

        .reasoning-nav button {
            padding: 5px 10px;
            font-size: 12px;
        }

        .reasoning-position {
            font-size: 12px;
            color: #666;
            text-align: center;
            margin-top: 5px;
        }
    </style>
    </style>
</head>
<body>
    <h1>Graph Traversal Visualizer üï∏Ô∏è</h1>

    <div class="container">
        <div class="controls">
            <h2>Define Graph</h2>
            <div class="input-method">
                <button id="textInputBtn" class="active">Text Input</button>
                <button id="visualEditorBtn">Visual Editor</button>
            </div>

            <div id="textInputArea">
                <label for="graphInput">Enter Edges (e.g., "1 2" or "1 2 6" per line):</label>
                <textarea id="graphInput" rows="10" placeholder="1 2&#10;1 3 5&#10;2 4"></textarea>
                <button id="submitTextGraph">Create Graph from Text</button>
            </div>

            <div id="traversalControls">
                <h2>Traversal</h2>
                <label for="startNode">Start Node:</label>
                <input type="text" id="startNode" placeholder="e.g., 1">
                <label for="endNode">End Node (for Dijkstra):</label>
                <input type="text" id="endNode" placeholder="e.g., 4">
                <select id="traversalAlgorithm">
                    <option value="bfs">Breadth-First Search (BFS)</option>
                    <option value="dfs">Depth-First Search (DFS)</option>
                    <option value="dijkstra">Dijkstra's Algorithm</option>
                    <option value="bellmanford">Bellman-Ford Algorithm</option>
                </select>
                <div class="traversal-controls">
                    <button id="runTraversal">Run Traversal</button>
                    <button id="pauseTraversal" style="display: none;">Pause</button>
                    <button id="continueTraversal" style="display: none;">Continue</button>
                    <button id="resetTraversal">Reset Visuals</button>
                </div>
            </div>
             <div id="speedControl">
                <label for="animationSpeed">Animation Speed:</label>
                <input type="range" id="animationSpeed" min="100" max="2000" value="500" step="100">
            </div>
        </div>

        <div class="visualizer-area">
            <h2>Graph Visualization</h2>
            <div id="network"></div>
            <div id="pathInfo" class="path-info" style="display: none;">
                <h3>Path Information</h3>
                <p id="pathDetails"></p>
                <p id="pathLength"></p>
            </div>
            <div id="reasoningPanel" class="reasoning-panel" style="display: none;">
                <div class="reasoning-content" id="reasoningContent"></div>
                <div class="reasoning-nav" id="reasoningNav">
                    <button id="reasoningPrev">‚óÄ Previous</button>
                    <span class="reasoning-position" id="reasoningPos">1/1</span>
                    <button id="reasoningNext">Next ‚ñ∂</button>
                </div>
            </div>
        </div>
    </div>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.9/dist/vis-network.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const graphInput = document.getElementById('graphInput');
            const submitTextGraphBtn = document.getElementById('submitTextGraph');
            const networkContainer = document.getElementById('network');
            const startNodeInput = document.getElementById('startNode');
            const endNodeInput = document.getElementById('endNode');
            const traversalAlgorithmSelect = document.getElementById('traversalAlgorithm');
            const runTraversalBtn = document.getElementById('runTraversal');
            const pauseTraversalBtn = document.getElementById('pauseTraversal');
            const continueTraversalBtn = document.getElementById('continueTraversal');
            const resetTraversalBtn = document.getElementById('resetTraversal');
            const textInputBtn = document.getElementById('textInputBtn');
            const visualEditorBtn = document.getElementById('visualEditorBtn');
            const textInputArea = document.getElementById('textInputArea');
            const animationSpeedSlider = document.getElementById('animationSpeed');
            const pathInfo = document.getElementById('pathInfo');
            const pathDetails = document.getElementById('pathDetails');
            const pathLength = document.getElementById('pathLength');

            const reasoningPanel = document.getElementById('reasoningPanel');
            const reasoningContent = document.getElementById('reasoningContent');
            const reasoningNav = document.getElementById('reasoningNav');
            const reasoningPrev = document.getElementById('reasoningPrev');
            const reasoningNext = document.getElementById('reasoningNext');
            const reasoningPos = document.getElementById('reasoningPos');

            // Track reasoning steps and current position
            let reasoningSteps = [];
            let currentStepIndex = -1;

            let nodes = new vis.DataSet([]);
            let edges = new vis.DataSet([]);
            let network = null;
            let rawGraphData = { nodes: new Set(), edges: [] };
            let animationDelay = 500;
            let isPaused = false;
            let isRunning = false;
            let resumePromise = null;
            let resolveResume = null;

            const defaultNodeColor = {
                border: '#2B7CE9',
                background: '#97C2FC',
                highlight: {
                    border: '#2B7CE9',
                    background: '#D2E5FF'
                },
                hover: {
                    border: '#2B7CE9',
                    background: '#D2E5FF'
                }
            };

            const defaultEdgeColor = '#848484';
            const defaultEdgeWidth = 2;
            const visitedNodeColor = { background: '#34c131', border: 'green' };
            const visitingNodeColor = { background: 'orange', border: 'darkorange' };
            const discoveredNodeColor = { background: '#a0e89f', border: 'darkgreen' };
            const negativeCycleColor = { background: '#ff6b6b', border: '#ff0000' };
            const pathEdgeColor = { color: '#ff5722', width: 4 };
            const visitedEdgeColor = { color: '#34c131', width: 4 };

            const defaultOptions = {
                physics: {
                    enabled: true,
                    solver: 'barnesHut',
                    barnesHut: {
                        gravitationalConstant: -4000,
                        centralGravity: 0.15,
                        springLength: 120,
                        springConstant: 0.05,
                        damping: 0.09,
                        avoidOverlap: 0.15
                    },
                    stabilization: {
                        iterations: 1500,
                        fit: true
                    }
                },
                interaction: {
                    dragNodes: true,
                    dragView: true,
                    hover: true,
                    tooltipDelay: 200,
                    zoomView: true,
                    navigationButtons: true,
                    keyboard: true
                },
                manipulation: {
                    enabled: false,
                    addNode: function (data, callback) {
                        data.label = prompt("Enter node ID/label:", "");
                        if (data.label !== null && data.label.trim() !== "") {
                            data.id = data.label.trim();
                            if (rawGraphData.nodes.has(data.id)) {
                                alert("Node ID already exists!");
                                callback(null);
                                return;
                            }
                            rawGraphData.nodes.add(data.id);
                            data.color = defaultNodeColor;
                            callback(data);
                        } else {
                            callback(null);
                        }
                    },
                    addEdge: function (data, callback) {
                        if (data.from === data.to) {
                            alert("Cannot connect node to itself (self-loops disabled in this mode).");
                            callback(null);
                            return;
                        }
                        const weightInput = prompt("Enter edge weight (optional, number):", "");
                        let weight = null;
                        let label = "";
                        if (weightInput !== null && weightInput.trim() !== "") {
                            weight = parseInt(weightInput);
                            if (isNaN(weight)) {
                                alert("Weight must be a number.");
                                callback(null);
                                return;
                            }
                            label = String(weight);
                        }
                        data.label = label;
                        data.arrows = 'to';
                        rawGraphData.edges.push({ from: data.from, to: data.to, weight: weight });
                        callback(data);
                    },
                    editNode: function (data, callback) {
                        const newLabel = prompt("Edit node ID/label:", data.label);
                        if (newLabel !== null && newLabel.trim() !== "" && newLabel.trim() !== data.id) {
                            const newId = newLabel.trim();
                            if (rawGraphData.nodes.has(newId)) {
                                alert("Node ID already exists!");
                                callback(null);
                                return;
                            }
                            rawGraphData.nodes.delete(data.id);
                            rawGraphData.nodes.add(newId);
                            rawGraphData.edges.forEach(edge => {
                                if (edge.from === data.id) edge.from = newId;
                                if (edge.to === data.id) edge.to = newId;
                            });
                            data.id = newId;
                            data.label = newId;
                        }
                        callback(data);
                    },
                    deleteNode: function (data, callback) {
                        data.nodes.forEach(nodeId => {
                            nodes.remove(nodeId);
                            rawGraphData.nodes.delete(nodeId);
                        });
                        rawGraphData.edges = rawGraphData.edges.filter(edge =>
                            !data.nodes.includes(edge.from) && !data.nodes.includes(edge.to)
                        );
                        callback(data);
                    },
                    deleteEdge: function (data, callback) {
                        data.edges.forEach(edgeId => {
                            const deletedVisEdge = edges.get(edgeId);
                            if(deletedVisEdge) {
                                rawGraphData.edges = rawGraphData.edges.filter(rawEdge =>
                                    !(rawEdge.from === deletedVisEdge.from && rawEdge.to === deletedVisEdge.to && 
                                      (rawEdge.weight === (parseInt(deletedVisEdge.label) || null) || 
                                      (!rawEdge.weight && !deletedVisEdge.label)))
                                );
                                edges.remove(edgeId);
                            }
                        });
                        callback(data);
                    }
                },
                nodes: {
                    shape: 'ellipse',
                    size: 22,
                    font: {
                        size: 14,
                        color: '#333333'
                    },
                    borderWidth: 2,
                    color: defaultNodeColor
                },
                edges: {
                    width: defaultEdgeWidth,
                    color: {
                        color: defaultEdgeColor,
                        highlight: '#007bff',
                        hover: '#0056b3'
                    },
                    arrows: {
                        to: { enabled: true, scaleFactor: 0.7, type: 'arrow' }
                    },
                    font: {
                        align: 'middle',
                        size: 12,
                        color: '#444',
                        strokeWidth: 3,
                        strokeColor: '#ffffff'
                    },
                    smooth: {
                        enabled: true,
                        type: "dynamic",
                        roundness: 0.5
                    }
                }
            };

            function addReasoning(text, type = '') {
                const line = document.createElement('div');
                line.className = `reasoning-line ${type}`;
                line.textContent = text;
                reasoningContent.appendChild(line);
                reasoningSteps.push(line);
                
                // If not paused, show only the latest
                if (!isPaused) {
                    if (currentStepIndex >= 0) {
                        reasoningSteps[currentStepIndex].classList.remove('active');
                    }
                    currentStepIndex = reasoningSteps.length - 1;
                    line.classList.add('active');
                    reasoningContent.scrollTop = reasoningContent.scrollHeight;
                }
                
                updatePosition();
                return line;
            }

            // Update navigation position display
            function updatePosition() {
                reasoningPos.textContent = `${currentStepIndex + 1}/${reasoningSteps.length}`;
                reasoningPrev.disabled = currentStepIndex <= 0;
                reasoningNext.disabled = currentStepIndex >= reasoningSteps.length - 1;
            }

            // Show specific reasoning step
            function showReasoningStep(index) {
                if (index < 0 || index >= reasoningSteps.length) return;
                
                // Hide current active
                if (currentStepIndex >= 0) {
                    reasoningSteps[currentStepIndex].classList.remove('active');
                }
                
                // Show new one
                currentStepIndex = index;
                reasoningSteps[currentStepIndex].classList.add('active');
                reasoningContent.scrollTop = reasoningSteps[currentStepIndex].offsetTop - reasoningContent.offsetTop;
                updatePosition();
            }

            // Navigation handlers
            reasoningPrev.addEventListener('click', () => {
                showReasoningStep(currentStepIndex - 1);
            });

            reasoningNext.addEventListener('click', () => {
                showReasoningStep(currentStepIndex + 1);
            });


            // Helper function to highlight reasoning line
            function highlightReasoningLine(line) {
                const lines = document.querySelectorAll('.reasoning-line');
                lines.forEach(l => l.classList.remove('highlight'));
                if (line) line.classList.add('highlight');
            }

            // Clear reasoning when resetting
            function resetTraversalVisualization() {
                // Previous reset code remains the same
                reasoningContent.innerHTML = '';
                reasoningPanel.style.display = 'none';
            }

            function initializeGraph(enableManipulation = false) {
                if (network) {
                    network.destroy();
                }
                const data = { nodes: nodes, edges: edges };
                const options = JSON.parse(JSON.stringify(defaultOptions));
                options.manipulation.enabled = enableManipulation;

                network = new vis.Network(networkContainer, data, options);

                network.on("stabilizationIterationsDone", function () {
                    network.fit();
                });

                if (enableManipulation) {
                    document.getElementById('textInputArea').style.display = 'none';
                    
                    if (rawGraphData.nodes.size > 0 && nodes.length === 0) {
                        rawGraphData.nodes.forEach(nodeId => {
                            if (!nodes.get(nodeId)) {
                                nodes.add({ id: nodeId, label: nodeId, color: defaultNodeColor });
                            }
                        });
                        rawGraphData.edges.forEach(edge => {
                            const edgeExists = edges.get({
                                filter: e => e.from === edge.from && e.to === edge.to && 
                                            (parseInt(e.label) || null) === edge.weight
                            });
                            if (edgeExists.length === 0) {
                                edges.add({
                                    from: edge.from,
                                    to: edge.to,
                                    label: edge.weight !== null ? String(edge.weight) : '',
                                    arrows: 'to',
                                    color: defaultEdgeColor,
                                    width: defaultEdgeWidth
                                });
                            }
                        });
                    }
                } else {
                    document.getElementById('textInputArea').style.display = 'block';
                }
            }

            function resetAllGraphData() {
                nodes.clear();
                edges.clear();
                rawGraphData = { nodes: new Set(), edges: [] };
                graphInput.value = '';
                startNodeInput.value = '';
                endNodeInput.value = '';
                pathInfo.style.display = 'none';
                if (network) {
                    network.setData({ nodes: nodes, edges: edges });
                }
            }

            submitTextGraphBtn.addEventListener('click', () => {
                try {
                    nodes.clear();
                    edges.clear();
                    rawGraphData = { nodes: new Set(), edges: [] };
                    
                    const inputText = graphInput.value.trim();
                    if (!inputText) {
                        alert("Please enter graph data in the text area.");
                        return;
                    }

                    const lines = inputText.split('\n');
                    const nodeMap = new Map();
                    const edgeList = [];

                    lines.forEach((line, lineNumber) => {
                        line = line.trim();
                        if (!line) return;

                        const parts = line.split(/\s+/).filter(part => part !== '');
                        
                        if (parts.length < 2 || parts.length > 3) {
                            throw new Error(`Line ${lineNumber + 1}: Each line must have 2 or 3 parts (node1 node2 [weight]). Found ${parts.length} parts.`);
                        }

                        const from = parts[0];
                        const to = parts[1];
                        let weight = null;

                        if (!from || !to) {
                            throw new Error(`Line ${lineNumber + 1}: Node IDs cannot be empty.`);
                        }

                        if (parts.length === 3) {
                            weight = parseFloat(parts[2]);
                            if (isNaN(weight)) {
                                throw new Error(`Line ${lineNumber + 1}: Weight must be a number. Found '${parts[2]}'`);
                            }
                        }

                        if (!nodeMap.has(from)) {
                            nodeMap.set(from, { id: from, label: from });
                        }
                        if (!nodeMap.has(to)) {
                            nodeMap.set(to, { id: to, label: to });
                        }

                        edgeList.push({
                            from: from,
                            to: to,
                            weight: weight,
                            label: weight !== null ? String(weight) : '',
                            arrows: 'to'
                        });
                    });

                    nodeMap.forEach((node, id) => {
                        rawGraphData.nodes.add(id);
                    });
                    edgeList.forEach(edge => {
                        rawGraphData.edges.push({
                            from: edge.from,
                            to: edge.to,
                            weight: edge.weight
                        });
                    });

                    const visNodes = Array.from(nodeMap.values()).map(node => ({
                        ...node,
                        color: defaultNodeColor
                    }));

                    const visEdges = edgeList.map(edge => ({
                        ...edge,
                        color: defaultEdgeColor,
                        width: defaultEdgeWidth
                    }));

                    nodes.update(visNodes);
                    edges.update(visEdges);

                    initializeGraph(false);
                    
                    if (network) {
                        network.once('stabilizationIterationsDone', () => {
                            network.fit({
                                animation: {
                                    duration: 1000,
                                    easingFunction: 'easeInOutQuad'
                                }
                            });
                        });
                    }

                } catch (error) {
                    alert(error.message);
                    console.error(error);
                    resetAllGraphData();
                }
            });

            textInputBtn.addEventListener('click', () => {
                textInputBtn.classList.add('active');
                visualEditorBtn.classList.remove('active');
                initializeGraph(false);
            });

            visualEditorBtn.addEventListener('click', () => {
                visualEditorBtn.classList.add('active');
                textInputBtn.classList.remove('active');
                initializeGraph(true);
            });

            function resetTraversalVisualization() {
                nodes.getIds().forEach(id => {
                    nodes.update({ id: id, color: defaultNodeColor });
                });
                edges.getIds().forEach(edgeId => {
                    edges.update({
                        id: edgeId,
                        color: defaultEdgeColor,
                        width: defaultEdgeWidth
                    });
                });
                pathInfo.style.display = 'none';
                if (network) {
                    network.unselectAll();
                }
                reasoningContent.innerHTML = '';
                reasoningPanel.style.display = 'none';

                reasoningSteps = [];
                currentStepIndex = -1;
            }

            resetTraversalBtn.addEventListener('click', resetTraversalVisualization);

            animationSpeedSlider.addEventListener('input', (event) => {
                animationDelay = parseInt(event.target.value);
            });

            pauseTraversalBtn.addEventListener('click', () => {
                isPaused = true;
                pauseTraversalBtn.style.display = 'none';
                continueTraversalBtn.style.display = 'inline-block';
                reasoningNav.style.display = 'flex';
                
                // When pausing, show navigation controls
                if (reasoningSteps.length > 0) {
                    showReasoningStep(currentStepIndex);
                }
            });

            continueTraversalBtn.addEventListener('click', () => {
                isPaused = false;
                pauseTraversalBtn.style.display = 'inline-block';
                continueTraversalBtn.style.display = 'none';
                reasoningNav.style.display = 'none';
                
                // When continuing, jump to latest
                if (reasoningSteps.length > 0) {
                    currentStepIndex = reasoningSteps.length - 1;
                    showReasoningStep(currentStepIndex);
                }
                
                if (resolveResume) {
                    resolveResume();
                    resolveResume = null;
                }
            });

            async function checkPause() {
                if (isPaused) {
                    return new Promise(resolve => {
                        resolveResume = resolve;
                    });
                }
                return Promise.resolve();
            }

            runTraversalBtn.addEventListener('click', async () => {
                if (isRunning) {
                    alert("A traversal is already running. Please wait or reset first.");
                    return;
                }

                const startNodeId = startNodeInput.value.trim();
                const endNodeId = endNodeInput.value.trim();
                const algorithm = traversalAlgorithmSelect.value;

                if (!startNodeId) {
                    alert("Please enter a start node.");
                    return;
                }
                if (!rawGraphData.nodes.has(startNodeId)) {
                    alert("Start node not found in the graph.");
                    return;
                }
                if (rawGraphData.nodes.size === 0) {
                    alert("Graph is empty. Please define a graph first.");
                    return;
                }
                if ((algorithm === 'dijkstra' || algorithm === 'bellmanford') && !endNodeId) {
                    alert(`Please enter an end node for ${algorithm === 'dijkstra' ? "Dijkstra's" : "Bellman-Ford"} algorithm.`);
                    return;
                }
                if ((algorithm === 'dijkstra' || algorithm === 'bellmanford') && !rawGraphData.nodes.has(endNodeId)) {
                    alert("End node not found in the graph.");
                    return;
                }

                resetTraversalVisualization();
                isRunning = true;
                isPaused = false;
                runTraversalBtn.disabled = true;
                pauseTraversalBtn.style.display = 'inline-block';
                continueTraversalBtn.style.display = 'none';

                try {
                    // Build adjacency list
                    const adj = {};
                    rawGraphData.nodes.forEach(node => adj[node] = []);
                    rawGraphData.edges.forEach(edge => {
                        const weight = edge.weight !== null ? edge.weight : 1;
                        adj[edge.from].push({node: edge.to, weight: weight});
                    });

                    if (algorithm === 'bfs') {
                        await bfs(startNodeId, adj);
                    } else if (algorithm === 'dfs') {
                        await dfs(startNodeId, adj);
                    } else if (algorithm === 'dijkstra') {
                        await dijkstra(startNodeId, endNodeId, adj);
                    } else if (algorithm === 'bellmanford') {
                        await bellmanFord(startNodeId, endNodeId, adj);
                    }
                } catch (error) {
                    console.error("Traversal error:", error);
                } finally {
                    isRunning = false;
                    runTraversalBtn.disabled = false;
                    pauseTraversalBtn.style.display = 'none';
                    continueTraversalBtn.style.display = 'none';
                }
            });

// Modified Bellman-Ford to include reasoning
            async function bellmanFord(startNode, endNode, adj) {
                reasoningPanel.style.display = 'block';
                addReasoning(`Bellman-Ford algorithm from ${startNode} to ${endNode}:`, 'info');
                
                // Initialize distances and predecessors
                const distances = {};
                const predecessors = {};
                rawGraphData.nodes.forEach(node => {
                    distances[node] = Infinity;
                    predecessors[node] = null;
                });
                distances[startNode] = 0;

                // Highlight start node
                await highlightNode(startNode, visitingNodeColor);
                addReasoning(`- Initialized distances, starting with node ${startNode} (distance = 0)`, 'selected');
                await checkPause();

                // Relax all edges |V| - 1 times
                const nodes = Array.from(rawGraphData.nodes);
                const edges = rawGraphData.edges.map(edge => ({
                    from: edge.from,
                    to: edge.to,
                    weight: edge.weight !== null ? edge.weight : 1
                }));

                let hasNegativeCycle = false;

                addReasoning(`\nStarting relaxation phase (${nodes.length - 1} iterations):`, 'info');
                
                // Main Bellman-Ford algorithm
                for (let i = 0; i < nodes.length - 1; i++) {
                    await checkPause();
                    let updated = false;
                    addReasoning(`\nIteration ${i + 1}:`, 'info');

                    for (const edge of edges) {
                        await checkPause();
                        const edgeLine = addReasoning(`- Checking edge ${edge.from} ‚Üí ${edge.to} (weight ${edge.weight})`);
                        highlightReasoningLine(edgeLine);
                        
                        if (distances[edge.from] + edge.weight < distances[edge.to]) {
                            distances[edge.to] = distances[edge.from] + edge.weight;
                            predecessors[edge.to] = edge.from;
                            updated = true;

                            addReasoning(`  - Relaxing edge: new distance to ${edge.to} = ${distances[edge.to]}`, 'selected');
                            
                            // Visualize the relaxation
                            await highlightEdge(edge.from, edge.to, pathEdgeColor);
                            await checkPause();
                            await highlightNode(edge.to, discoveredNodeColor);
                            await checkPause();
                        } else {
                            addReasoning(`  - No relaxation needed (current distance ${distances[edge.to]} <= ${distances[edge.from]} + ${edge.weight})`, 'ignored');
                        }
                    }

                    if (!updated) {
                        addReasoning("- No updates in this iteration, terminating early", 'info');
                        break;
                    }
                }

                // Check for negative cycles
                addReasoning(`\nChecking for negative cycles:`, 'info');
                for (const edge of edges) {
                    await checkPause();
                    const edgeLine = addReasoning(`- Checking edge ${edge.from} ‚Üí ${edge.to} (weight ${edge.weight})`);
                    highlightReasoningLine(edgeLine);
                    
                    if (distances[edge.from] + edge.weight < distances[edge.to]) {
                        hasNegativeCycle = true;
                        addReasoning(`  - Negative cycle detected! ${edge.from} ‚Üí ${edge.to} can be relaxed further`, 'error');
                        
                        // Highlight the negative cycle edge
                        await highlightEdge(edge.from, edge.to, { color: '#ff0000', width: 4 });
                        await highlightNode(edge.from, negativeCycleColor);
                        await highlightNode(edge.to, negativeCycleColor);
                        break;
                    } else {
                        addReasoning(`  - No negative cycle (distance ${distances[edge.to]} <= ${distances[edge.from]} + ${edge.weight})`, 'ignored');
                    }
                }

                // Display results
                if (hasNegativeCycle) {
                    pathDetails.innerHTML = "<strong>Negative cycle detected!</strong> Graph contains a negative-weight cycle.";
                    pathLength.textContent = "";
                    pathInfo.style.display = 'block';
                    pathInfo.classList.add('negative-cycle');
                    return;
                }

                // Reconstruct path if no negative cycle
                const path = [];
                let current = endNode;
                while (current !== null) {
                    path.unshift(current);
                    current = predecessors[current];
                }

                if (path.length > 1) {
                    pathDetails.textContent = `Path: ${path.join(' ‚Üí ')}`;
                    pathLength.textContent = `Total distance: ${distances[endNode]}`;
                    pathInfo.style.display = 'block';
                    pathInfo.classList.remove('negative-cycle');
                    
                    // Highlight the path
                    addReasoning(`\nFinal path found:`, 'info');
                    for (let i = 0; i < path.length - 1; i++) {
                        await checkPause();
                        const from = path[i];
                        const to = path[i+1];
                        const weight = edges.find(e => e.from === from && e.to === to).weight;
                        addReasoning(`- ${from} ‚Üí ${to} (weight ${weight})`, 'selected');
                        await highlightEdge(from, to, pathEdgeColor);
                        await checkPause();
                        await highlightNode(from, visitingNodeColor);
                        await checkPause();
                    }
                    await highlightNode(path[path.length-1], visitingNodeColor);
                } else {
                    pathDetails.textContent = "No path found";
                    pathLength.textContent = "";
                    pathInfo.style.display = 'block';
                    pathInfo.classList.remove('negative-cycle');
                    addReasoning("\nNo path found to target node", 'error');
                }
                addReasoning("\nAlgorithm complete", 'info');
            }


            async function highlightNode(nodeId, style = visitedNodeColor) {
                nodes.update({ id: nodeId, color: style });
                await new Promise(resolve => setTimeout(resolve, animationDelay));
                await checkPause();
            }

            async function highlightEdge(fromNode, toNode, style = visitedEdgeColor) {
                const edgesBetween = edges.get({
                    filter: edge => edge.from === fromNode && edge.to === toNode
                });

                for (const edge of edgesBetween) {
                    edges.update({ 
                        id: edge.id, 
                        color: style.color, 
                        width: style.width 
                    });
                }
                await new Promise(resolve => setTimeout(resolve, animationDelay));
                await checkPause();
            }
            // Modified BFS to include reasoning (similar modifications for other algorithms)
            async function bfs(startNode, adj) {
                reasoningPanel.style.display = 'block';
                reasoningSteps = [];
                currentStepIndex = -1;
                
                const reasoningHeader = addReasoning(`BFS starting from node ${startNode}:`, 'info');
                
                const visited = new Set();
                const queue = [startNode];
                visited.add(startNode);

                await highlightNode(startNode, visitingNodeColor);
                addReasoning(`- Visited start node ${startNode}`, 'selected');
                await checkPause();

                let count = 0;
                const maxIterations = rawGraphData.nodes.size * 2;

                while (queue.length > 0 && count < maxIterations) {
                    await checkPause();
                    count++;
                    const u = queue.shift();
                    const currentLine = addReasoning(`Processing node ${u}:`, 'info');
                    
                    await highlightNode(u, visitedNodeColor);
                    await checkPause();

                    if(adj[u]) {
                        for (const edgeInfo of adj[u]) {
                            await checkPause();
                            const v = edgeInfo.node;
                            const edgeLine = addReasoning(`Examining edge ${u} ‚Üí ${v}...`);

                            if (!visited.has(v)) {
                                visited.add(v);
                                addReasoning(`  Node ${v} not visited yet, adding to queue`, 'selected');
                                await highlightEdge(u, v);
                                await checkPause();
                                await highlightNode(v, discoveredNodeColor);
                                await checkPause();
                                queue.push(v);
                            } else {
                                addReasoning(`  Node ${v} already visited, skipping`, 'ignored');
                            }
                        }
                    }
                    addReasoning(`Finished processing node ${u}`, 'info');
                }
                if (count >= maxIterations) {
                    addReasoning("Warning: BFS terminated early due to iteration limit", 'error');
                    console.warn("BFS safety break triggered.");
                }
                addReasoning("BFS complete", 'info');
            }



            // Modified DFS to include reasoning
            async function dfsUtil(u, adj, visited, depth = 0) {
                await checkPause();
                const indent = '  '.repeat(depth);
                const currentLine = addReasoning(`${indent}Visiting node ${u} (depth ${depth})`, 'info');
                highlightReasoningLine(currentLine);
                
                visited.add(u);
                await highlightNode(u, visitedNodeColor);
                await checkPause();

                if (adj[u]) {
                    for (const edgeInfo of adj[u]) {
                        await checkPause();
                        const v = edgeInfo.node;
                        const edgeLine = addReasoning(`${indent}- Examining edge ${u} ‚Üí ${v}...`);
                        highlightReasoningLine(edgeLine);

                        if (!visited.has(v)) {
                            addReasoning(`${indent}  - Node ${v} not visited yet, recursing`, 'selected');
                            await highlightEdge(u, v);
                            await checkPause();
                            await dfsUtil(v, adj, visited, depth + 1);
                        } else {
                            addReasoning(`${indent}  - Node ${v} already visited, backtracking`, 'ignored');
                        }
                    }
                }
                addReasoning(`${indent}Backtracking from node ${u}`, 'info');
            }

            async function dfs(startNode, adj) {
                reasoningPanel.style.display = 'block';
                addReasoning(`DFS starting from node ${startNode}:`, 'info');
                const visited = new Set();
                await highlightNode(startNode, visitingNodeColor);
                await checkPause();
                await dfsUtil(startNode, adj, visited);
                addReasoning("\nDFS complete", 'info');
            }

            async function dijkstra(startNode, endNode, adj) {
                reasoningPanel.style.display = 'block';
                addReasoning(`Dijkstra's algorithm from ${startNode} to ${endNode}:`, 'info');
                
                // Initialize distances and previous nodes
                const distances = {};
                const previous = {};
                const visited = new Set();
                const unvisited = new Set(rawGraphData.nodes);
                
                rawGraphData.nodes.forEach(node => {
                    distances[node] = Infinity;
                    previous[node] = null;
                });
                distances[startNode] = 0;
                
                // Highlight start node
                await highlightNode(startNode, visitingNodeColor);
                addReasoning(`- Initialized distances, starting with node ${startNode} (distance = 0)`, 'selected');
                await checkPause();
                
                while (unvisited.size > 0) {
                    await checkPause();
                    // Find node with smallest distance
                    let current = null;
                    let smallestDistance = Infinity;
                    
                    for (const node of unvisited) {
                        if (distances[node] < smallestDistance) {
                            smallestDistance = distances[node];
                            current = node;
                        }
                    }
                    
                    const currentLine = addReasoning(`\nCurrent node: ${current} (distance = ${distances[current]})`, 'info');
                    highlightReasoningLine(currentLine);
                    
                    if (current === null || current === endNode) {
                        if (current === null) addReasoning("- No reachable nodes left", 'info');
                        else addReasoning(`- Reached target node ${endNode}`, 'selected');
                        break;
                    }
                    
                    // Mark as visited
                    unvisited.delete(current);
                    visited.add(current);
                    await highlightNode(current, visitedNodeColor);
                    addReasoning(`- Marked node ${current} as visited`, 'info');
                    await checkPause();
                    
                    // Update neighbors
                    if (adj[current]) {
                        for (const edge of adj[current]) {
                            await checkPause();
                            const neighbor = edge.node;
                            if (visited.has(neighbor)) {
                                addReasoning(`- Neighbor ${neighbor} already visited, skipping`, 'ignored');
                                continue;
                            }
                            
                            const alt = distances[current] + edge.weight;
                            const edgeLine = addReasoning(`- Checking edge ${current} ‚Üí ${neighbor} (weight ${edge.weight})`);
                            highlightReasoningLine(edgeLine);
                            
                            if (alt < distances[neighbor]) {
                                distances[neighbor] = alt;
                                previous[neighbor] = current;
                                addReasoning(`  - Found shorter path to ${neighbor}: new distance = ${alt}`, 'selected');
                                
                                // Highlight the edge and node
                                await highlightEdge(current, neighbor);
                                await checkPause();
                                await highlightNode(neighbor, discoveredNodeColor);
                                await checkPause();
                            } else {
                                addReasoning(`  - Current path to ${neighbor} (distance = ${distances[neighbor]}) is shorter`, 'ignored');
                            }
                        }
                    }
                }
                
                // Reconstruct path
                const path = [];
                let current = endNode;
                while (current !== null) {
                    path.unshift(current);
                    current = previous[current];
                }
                
                // Display path information
                if (path.length > 1) {
                    pathDetails.textContent = `Path: ${path.join(' ‚Üí ')}`;
                    pathLength.textContent = `Total distance: ${distances[endNode]}`;
                    pathInfo.style.display = 'block';
                    
                    // Highlight the path
                    addReasoning(`\nFinal path found:`, 'info');
                    for (let i = 0; i < path.length - 1; i++) {
                        await checkPause();
                        const from = path[i];
                        const to = path[i+1];
                        const weight = adj[from].find(e => e.node === to).weight;
                        addReasoning(`- ${from} ‚Üí ${to} (weight ${weight})`, 'selected');
                        await highlightEdge(from, to, pathEdgeColor);
                        await checkPause();
                        await highlightNode(from, visitingNodeColor);
                        await checkPause();
                    }
                    await highlightNode(path[path.length-1], visitingNodeColor);
                } else {
                    pathDetails.textContent = "No path found";
                    pathLength.textContent = "";
                    pathInfo.style.display = 'block';
                    addReasoning("\nNo path found to target node", 'error');
                }
                addReasoning("\nAlgorithm complete", 'info');
            }


            // Initialize with text input mode by default
            initializeGraph(false);
        });
    </script>
</body>
</html>