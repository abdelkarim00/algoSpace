
<div>

<h1>Two Pointers Algorithm Explained</h1>

<p>The two pointers algorithm is a technique used to solve problems involving arrays or linked lists by maintaining two pointers that move through the data structure, often in a coordinated manner. This approach can significantly reduce the time complexity compared to naive nested loop solutions.</p>

<h2>Algorithm</h2>

<p>The core idea of the two pointers algorithm involves using two index variables (pointers) to traverse the data structure. The exact movement and conditions for these pointers depend on the specific problem, but common patterns include:</p>

<ul>
  <li><strong>Same Direction, Different Speeds:</strong> One pointer moves ahead of the other, often with a fixed gap or based on a certain condition. This is useful for finding pairs with a specific difference or for problems involving slow and fast pointers in linked lists.</li>
  <li><strong>Opposite Directions:</strong> One pointer starts at the beginning and moves towards the end, while the other starts at the end and moves towards the beginning. This is effective for problems involving sorted arrays where you need to find pairs that satisfy a certain condition (e.g., sum to a target).</li>
  <li><strong>Sliding Window (Special Case):</strong> The two pointers define the boundaries of a window that expands or contracts as the pointers move. This is closely related to the sliding window technique but often involves more dynamic movement of both pointers.</li>
</ul>

<p>The general steps often involve:</p>

<ol>
  <li><strong>Initialization:</strong> Initialize the two pointers to appropriate starting positions (e.g., both at the beginning, one at the beginning and one at the end, or with a specific offset).</li>
  <li><strong>Movement and Condition Check:</strong> Move the pointers based on certain conditions. These conditions usually involve the values at the current pointer positions and the problem's constraints.</li>
  <li><strong>Termination:</strong> Continue moving the pointers until a specific termination condition is met (e.g., one or both pointers reach the end of the data structure, a desired condition is found).</li>
  <li><strong>Result Tracking:</strong> Keep track of the desired result (e.g., indices of pairs, count of valid subarrays) as the pointers move.</li>
</ol>

<h2>Mathematics</h2>

<p>The mathematical concepts involved in the two pointers algorithm are often related to the properties of the data structure being traversed, especially if it's sorted. Some common mathematical ideas include:</p>

<ul>
  <li><strong>Ordering (for sorted arrays):</strong> When dealing with sorted arrays and two pointers moving in opposite directions, the ordering allows us to make informed decisions about how to move the pointers. For example, if we are looking for a pair that sums to a target value, and the current sum is less than the target, we know we need to increase the sum, so we move the left pointer to a larger element. Conversely, if the sum is greater than the target, we move the right pointer to a smaller element.</li>
  <li><strong>Invariant Maintenance:</strong> In some two-pointer approaches, especially those involving sliding windows or maintaining a certain property, the algorithm works by maintaining an invariant condition as the pointers move. For instance, in finding a subarray with a specific sum, the invariant might be that the window defined by the two pointers always has a sum less than or equal to the target.</li>
</ul>

<h2>Time and Memory Complexity</h2>

<ul>
  <li><strong>Time Complexity:</strong> The beauty of the two pointers algorithm lies in its efficiency. In most cases, each pointer traverses the data structure at most once. Therefore, the overall time complexity is often linear, i.e., $O(n)$, where $n$ is the size of the input array or linked list. This is a significant improvement over naive $O(n^2)$ or higher complexity solutions that might involve nested loops.</li>
  <li><strong>Memory Complexity:</strong> The memory complexity of the two pointers algorithm is typically constant, $O(1)$, as we are only using a few extra variables (the pointers themselves and possibly some temporary variables) regardless of the input size.</li>
</ul>

<h2>Easy Problems</h2>

<h3>Problem 1: Check if Pair Sum Exists (Codeforces - Hypothetical)</h3>
<p><strong>Problem Statement (Hypothetical):</strong> Given a sorted array of integers `arr` and a target value `target`, determine if there exists a pair of elements in `arr` whose sum is equal to `target`. Return "YES" if such a pair exists, and "NO" otherwise.</p>

<p><strong>Input Example:</strong></p>
<pre><code>
arr = [2, 7, 11, 15]
target = 9
</code></pre>

<p><strong>Output Example:</strong></p>
<pre><code>
YES (2 + 7 = 9)
</code></pre>

<p><strong>C++ Code:</strong></p>
<pre><code>
#include <iostream>
#include <vector>

int main() {
    std::vector<int> arr = {2, 7, 11, 15};
    int target = 9;
    int left = 0;
    int right = arr.size() - 1;
    bool found = false;

    while (left < right) {
        int currentSum = arr[left] + arr[right];
        if (currentSum == target) {
            found = true;
            break;
        } else if (currentSum < target) {
            left++;
        } else {
            right--;
        }
    }

    if (found) {
        std::cout << "YES" << std::endl;
    } else {
        std::cout << "NO" << std::endl;
    }

    return 0;
}
</code></pre>

<h3>Problem 2: Remove Duplicates from Sorted Array (In-place) (Codeforces - Variation)</h3>
<p><a href="https://codeforces.com/problemset/problem/1619/A">Codeforces Problem 1619A (Unrelated, but similar difficulty might exist. This is a conceptual adaptation.)</a></p>
<p><strong>Problem Statement (Variation):</strong> Given a sorted array of integers `nums`, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Return the new length of the array after removing the duplicates.</p>

<p><strong>Input Example:</strong></p>
<pre><code>
nums = [1, 1, 2, 2, 3, 4, 4, 5]
</code></pre>

<p><strong>Output Example:</strong></p>
<pre><code>
5 (The first 5 elements of nums should be [1, 2, 3, 4, 5])
</code></pre>

<p><strong>C++ Code:</strong></p>
<pre><code>
#include <iostream>
#include <vector>

int main() {
    std::vector<int> nums = {1, 1, 2, 2, 3, 4, 4, 5};
    if (nums.empty()) {
        std::cout << 0 << std::endl;
        return 0;
    }
    int writeIndex = 1;
    for (int readIndex = 1; readIndex < nums.size(); ++readIndex) {
        if (nums[readIndex] != nums[readIndex - 1]) {
            nums[writeIndex] = nums[readIndex];
            writeIndex++;
        }
    }
    std::cout << writeIndex << std::endl;
    // To see the modified array (not required by the problem, but for understanding):
    // for (int i = 0; i < writeIndex; ++i) {
    //     std::cout << nums[i] << " ";
    // }
    // std::cout << std::endl;
    return 0;
}
</code></pre>

<h2>Intermediate Problems</h2>

<h3>Problem 3: Three Sum (Codeforces - Variation)</h3>
<p><a href="https://codeforces.com/problemset/problem/1353/B">Codeforces Problem 1353B (Unrelated, but the difficulty level is comparable. This is a conceptual adaptation.)</a></p>
<p><strong>Problem Statement (Variation):</strong> Given an array of integers `nums`, find all unique triplets `(a, b, c)` in `nums` such that `a + b + c == 0`. The order of the triplets does not matter.</p>

<p><strong>Input Example:</strong></p>
<pre><code>
nums = [-1, 0, 1, 2, -1, -4]
</code></pre>

<p><strong>Output Example:</strong></p>
<pre><code>
[[-1, -1, 2], [-1, 0, 1]]
</code></pre>

<p><strong>C++ Code:</strong></p>
<pre><code>
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>

int main() {
    std::vector<int> nums = {-1, 0, 1, 2, -1, -4};
    std::sort(nums.begin(), nums.end());
    std::set<std::vector<int>> result;
    int n = nums.size();

    for (int i = 0; i < n - 2; ++i) {
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue; // Skip duplicate first elements
        }
        int left = i + 1;
        int right = n - 1;
        int target = -nums[i];

        while (left < right) {
            int sum = nums[left] + nums[right];
            if (sum == target) {
                result.insert({nums[i], nums[left], nums[right]});
                left++;
                right--;
                while (left < right && nums[left] == nums[left - 1]) left++; // Skip duplicate second elements
                while (left < right && nums[right] == nums[right + 1]) right--; // Skip duplicate third elements
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
    }

    // Output the result (for demonstration)
    for (const auto& triplet : result) {
        std::cout << "[" << triplet[0] << ", " << triplet[1] << ", " << triplet[2] << "]" << std::endl;
    }

    return 0;
}
</code></pre>

<h3>Problem 4: Container With Most Water (Codeforces - Conceptual Adaptation)</h3>
<p><strong>Problem Statement (Conceptual Adaptation):</strong> Given an array of non-negative integers `height` representing the heights of vertical lines drawn at each index of the array. The width of each bar is 1. Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water the container can store.</p>

<p><strong>Input Example:</strong></p>
<pre><code>
height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
</code></pre>

<p><strong>Output Example:</strong></p>
<pre><code>
49 (The two lines at indices 1 and 8 with heights 8 and 7 form a container of width 7 and height min(8, 7) = 7, so area = 7 * 7 = 49)
</code></pre>

<p><strong>C++ Code:</strong></p>
<pre><code>
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> height = {1, 8, 6, 2, 5, 4, 8, 3, 7};
    int left = 0;
    int right = height.size() - 1;
    int maxArea = 0;

    while (left < right) {
        int currentHeight = std::min(height[left], height[right]);
        int currentWidth = right - left;
        int currentArea = currentHeight * currentWidth;
        maxArea = std::max(maxArea, currentArea);

        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }

    std::cout << maxArea << std::endl;

    return 0;
}
</code></pre>

<h2>Hard Problem</h2>

<h3>Problem 5: Trapping Rain Water (Codeforces - Conceptual Adaptation)</h3>
<p><strong>Problem Statement (Conceptual Adaptation):</strong> Given an array of non-negative integers `height` representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</p>

<p><strong>Input Example:</strong></p>
<pre><code>
height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
</code></pre>

<p><strong>Output Example:</strong></p>
<pre><code>
6
</code></pre>

<p><strong>C++ Code:</strong></p>
<pre><code>
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
    int n = height.size();
    if (n == 0) {
        std::cout << 0 << std::endl;
        return 0;
    }
    int left = 0;
    int right = n - 1;
    int leftMax = 0;
    int rightMax = 0;
    int trappedWater = 0;

    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] >= leftMax) {
                leftMax = height[left];
            } else {
                trappedWater += leftMax - height[left];
            }
            left++;
        } else {
            if (height[right] >= rightMax) {
                rightMax = height[right];
            } else {
                trappedWater += rightMax - height[right];
            }
            right--;
        }
    }

    std::cout << trappedWater << std::endl;

    return 0;
}
</code></pre>

</div>
